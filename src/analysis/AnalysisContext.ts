import type ast from 'luaparse'
import type { LuaScope } from '../common'
import { TypeResolver } from './TypeResolver'
import { ClassResolver } from './ClassResolver'
import { AnalysisFinalizer } from './AnalysisFinalizer'
import type {
    LuaExpression,
    LuaExpressionInfo,
    LiteralTableField,
    FunctionInfo,
    TableInfo,
    ResolvedModule,
    AnalysisContextArgs,
    AssignmentItem,
    FunctionDefinitionItem,
    RequireAssignmentItem,
    ResolvedScopeItem,
} from './types'

/**
 * Shared context for analysis of a set of Lua files.
 */
export class AnalysisContext {
    /**
     * Associates file aliases to file identifiers.
     */
    aliasMap: Map<string, Set<string>>

    /**
     * Flag for whether heuristics based on item names should be applied.
     */
    applyHeuristics: boolean

    /**
     * Helper for finding and resolving class definitions.
     */
    classResolver: ClassResolver

    /**
     * The identifier of the module being processed.
     */
    currentModule: string

    /**
     * Associates IDs to lists of definitions.
     * IDs can be either global identifier names or `@`-prefixes generated by the scope.
     */
    definitions: Map<string, LuaExpressionInfo[]>

    /**
     * Helper for finalizing analyzed types.
     */
    finalizer: AnalysisFinalizer

    /**
     * Flag for whether the analysis is running in the context of Rosetta initialization or updating.
     */
    isForRosetta: boolean

    /**
     * Associates file identifiers to resolved modules.
     */
    modules: Map<string, ResolvedModule>

    /**
     * Helper for resolving types.
     */
    typeResolver: TypeResolver

    /**
     * Associates expressions to types inferred by usage.
     */
    usageTypes: Map<LuaExpression, Set<string>>

    /**
     * Associates unrecognized global names to temporary table IDs used to represent them.
     * This is reset for each module.
     */
    unknownClasses: Map<string, string>

    /**
     * Associates function declarations to function IDs.
     */
    protected functionToId: Map<ast.FunctionDeclaration, string>

    /**
     * Associates function IDs to info about the function they describe.
     */
    protected idToFunctionInfo: Map<string, FunctionInfo>

    /**
     * Associates table IDs to info about the table they describe.
     */
    protected idToTableInfo: Map<string, TableInfo>

    /**
     * The next available table ID number.
     */
    protected nextTableIndex: number = 1

    /**
     * The next available function ID number.
     */
    protected nextFunctionIndex: number = 1

    /**
     * Associates parameter IDs to the function IDs of their containing function.
     */
    protected parameterToFunctionId: Map<string, string>

    /**
     * Associates table constructor expressions to table IDs.
     */
    protected tableToId: Map<ast.TableConstructorExpression, string>

    /**
     * Creates a new analysis context.
     * @param args Arguments containing flags.
     */
    constructor(args: AnalysisContextArgs) {
        this.currentModule = ''
        this.aliasMap = new Map()
        this.tableToId = new Map()
        this.functionToId = new Map()
        this.idToTableInfo = new Map()
        this.idToFunctionInfo = new Map()
        this.parameterToFunctionId = new Map()
        this.definitions = new Map()
        this.usageTypes = new Map()
        this.unknownClasses = new Map()
        this.modules = new Map()

        this.classResolver = new ClassResolver(this)
        this.typeResolver = new TypeResolver(this)
        this.finalizer = new AnalysisFinalizer(this)

        this.isForRosetta = args.isForRosetta ?? false
        this.applyHeuristics = args.heuristics ?? false
    }

    /**
     * Adds an assignment to the list of definitions or fields.
     * This also resolves partial items associated with the assignment.
     * @param scope The current scope.
     * @param item The item to add and resolve.
     */
    addAssignment(
        scope: LuaScope,
        item: AssignmentItem | FunctionDefinitionItem | RequireAssignmentItem,
    ) {
        scope.addItem(item)
        this.typeResolver.resolveAssignment(scope, item)
    }

    /**
     * Returns the current module's name, which is the last part of the file identifier path.
     */
    getCurrentModuleName(): string {
        const slash = this.currentModule.lastIndexOf('/')
        if (slash === -1) {
            return this.currentModule
        }

        return this.currentModule.slice(slash + 1)
    }

    /**
     * Gets the list of definitions associated with an item ID.
     * If no definitions exist, this returns an empty list.
     * @param id The item ID. This can be a global name or an `@`-prefixed ID.
     */
    getDefinitions(id: string): LuaExpressionInfo[] {
        return this.definitions.get(id) ?? []
    }

    /**
     * Gets or creates the ID to use for a function.
     * @param expr The function AST node.
     * @param name The name to associate with an ID, if a new one is created.
     */
    getFunctionId(expr: ast.FunctionDeclaration, name?: string): string {
        let id = this.functionToId.get(expr)
        if (!id) {
            const count = this.nextFunctionIndex++
            id = `@function(${count})` + (name ? `[${name}]` : '')

            this.functionToId.set(expr, id)
        }

        return id
    }

    /**
     * Gets a function ID given one of its parameters' IDs.
     * @param id The parameter ID.
     */
    getFunctionIdFromParamId(id: string): string | undefined {
        return this.parameterToFunctionId.get(id)
    }

    /**
     * Gets or creates function info.
     * @param id The function ID.
     * @see getFunctionId for the method to get a function ID.
     */
    getFunctionInfo(id: string): FunctionInfo {
        let info = this.idToFunctionInfo.get(id)
        if (info) {
            return info
        }

        info = {
            id,
            parameters: [],
            parameterNames: [],
            parameterTypes: [],
            returnTypes: [],
            returnExpressions: [],
        }

        this.idToFunctionInfo.set(id, info)
        return info
    }

    /**
     * Gets a resolved module given its name.
     * @param name The module name.
     * @param checkAliases Flag for whether aliases should be used to find the module.
     */
    getModule(name: string, checkAliases = false): ResolvedModule | undefined {
        let mod = this.modules.get(name)
        if (mod || !checkAliases) {
            return mod
        }

        let alias = this.aliasMap.get(name)
        const firstAlias = alias ? [...alias][0] : undefined
        return firstAlias ? this.modules.get(firstAlias) : undefined
    }

    /**
     * Gets or creates the ID to use for a table.
     * @param expr The table literal AST node.
     * @param name The name to associate with an ID, if a new one is created.
     */
    getTableId(expr: ast.TableConstructorExpression, name?: string): string {
        let id = this.tableToId.get(expr)
        if (!id) {
            id = this.newTableId(name)
            this.tableToId.set(expr, id)
        }

        return id
    }

    /**
     * Gets or creates table info.
     * @param id A table ID.
     * @see getTableId for the method to get a table ID.
     * @see newTableId for the method to create a new table ID.
     */
    getTableInfo(id: string): TableInfo {
        let info = this.idToTableInfo.get(id)
        if (info) {
            return info
        }

        info = {
            id,
            literalFields: [],
            definitions: new Map(),
            definingModule: this.currentModule,
        }

        this.idToTableInfo.set(id, info)
        return info
    }

    /**
     * Creates a new table ID.
     * @param name A name to include in the ID.
     */
    newTableId(name?: string): string {
        const count = this.nextTableIndex++
        return `@table(${count})` + (name ? `[${name}]` : '')
    }

    /**
     * Sets the current module being processed.
     * @param id The file identifier for the current module.
     */
    setCurrentReadingModule(id?: string) {
        this.currentModule = id ?? ''
        this.unknownClasses.clear()
    }

    /**
     * Sets up basic information for a function.
     * @param functionId The function ID generated by `getFunctionId`.
     * @param scope The current scope.
     * @param node The AST node for the function.
     * @param identExpr An identifier expression used for the function name.
     */
    setFunctionInfo(
        functionId: string,
        scope: LuaScope,
        node: ast.FunctionDeclaration,
        identExpr: LuaExpression | undefined,
    ): string[] {
        const info = this.getFunctionInfo(functionId)
        info.identifierExpression = identExpr

        this.typeResolver.resolveFunctionParams(scope, node, info)

        for (const param of info.parameters) {
            this.parameterToFunctionId.set(param, functionId)
        }

        return info.parameters
    }

    /**
     * Associates a file identifier with information about a resolved module.
     * @param id The file identifier.
     * @param scope The current scope.
     * @param resolved The resolved module scope.
     */
    setResolvedModule(
        id: string,
        scope: LuaScope,
        resolved: ResolvedScopeItem,
    ) {
        const module = resolved as ResolvedModule
        module.scope = scope
        module.returns ??= []
        this.modules.set(id, module)
    }

    /**
     * Sets the fields used in a table literal.
     * These are used later for expression rewriting.
     * @param scope The current scope.
     * @param tableId The table ID generated with `newTableId`.
     * @param fields A list of table fields.
     */
    setTableLiteralFields(
        scope: LuaScope,
        tableId: string,
        fields: LiteralTableField[],
    ) {
        const info = this.getTableInfo(tableId)
        info.literalFields = fields

        this.typeResolver.resolveTableLiteralFields(scope, info)
    }
}
